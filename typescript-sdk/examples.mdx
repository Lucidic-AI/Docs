---
title: 'Examples'
description: 'Complete examples showing TypeScript SDK usage patterns'
---

## Overview

This page contains detailed examples showing how to use Lucidic's TypeScript SDK in real-world scenarios. All examples assume you've already set up your credentials.

## Basic Session Management

```typescript
import { LucidicAI } from 'lucidicai';
import OpenAI from 'openai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function basicExample() {
    const openai = new OpenAI();

    // Use context manager for session lifecycle
    await client.sessions.create({
        sessionName: 'Document Processor',
        task: 'Process and summarize documents'
    }, async () => {
        // Read document
        const document = await readDocument();

        // LLM calls are auto-tracked as events
        const response = await openai.chat.completions.create({
            model: 'gpt-4',
            messages: [
                { role: 'system', content: 'Summarize the document' },
                { role: 'user', content: document }
            ]
        });

        // Emit custom event
        client.events.emit({
            name: 'Document processed',
            output: { summary: response.choices[0].message.content }
        });
    });
    // Session auto-ends when callback completes
}
```

## Error Handling Patterns

```typescript
import { LucidicAI, APIError } from 'lucidicai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function robustWorkflow() {
    try {
        await client.sessions.create({
            sessionName: 'Fault-tolerant workflow'
        }, async () => {
            try {
                // Risky operation
                const result = await riskyOperation();

                // Track success
                client.events.emit({
                    name: 'Operation completed',
                    output: { success: true, result }
                });

            } catch (error) {
                // Track failure
                client.events.emit({
                    name: 'Operation failed',
                    output: { error: error.message },
                    metadata: { errorType: error.constructor.name }
                });
                throw error;
            }
        });

    } catch (error) {
        if (error instanceof APIError) {
            console.error('API error:', error.message);
        }
    }
}
```

## Working with Events

```typescript
import { LucidicAI } from 'lucidicai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function eventTrackingExample() {
    await client.sessions.create({
        sessionName: 'Event tracking demo'
    }, async () => {
        // Zero-latency event for hot paths
        client.events.emit({
            name: 'Database query',
            input: { query: 'SELECT * FROM users' },
            output: { count: 150 },
            durationMs: 45
        });

        // Synchronous event when you need the ID
        const event = await client.events.create({
            name: 'External API call',
            input: { endpoint: '/api/weather' }
        });

        const weather = await fetchWeatherData();

        // Can reference the event ID if needed
        console.log(`Created event: ${event.eventId}`);
    });
}
```

## Long-Running Workflows

```typescript
import { LucidicAI } from 'lucidicai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function longRunningPipeline(documentBatch: string[]) {
    // Phase 1: Initialize and preprocess
    let sessionId: string;

    await client.sessions.create({
        sessionName: 'Document batch processing',
        task: `Process ${documentBatch.length} documents`
    }, async (session) => {
        sessionId = session.sessionId;

        const validDocs = await preprocessDocuments(documentBatch);

        client.events.emit({
            name: 'Preprocessing complete',
            output: { validCount: validDocs.length }
        });

        // Save progress
        await saveCheckpoint({ sessionId, validDocs });
    });

    // Phase 2: Continue in same session
    await client.sessions.create({
        sessionId  // Continue existing session
    }, async () => {
        const checkpoint = await loadCheckpoint(sessionId);

        for (const [index, doc] of checkpoint.validDocs.entries()) {
            try {
                await processDocument(doc);

                client.events.emit({
                    name: `Document ${index + 1} processed`,
                    output: { success: true }
                });
            } catch (error) {
                client.events.emit({
                    name: `Document ${index + 1} failed`,
                    output: { error: error.message }
                });
            }
        }

        // Update session with final status
        await client.sessions.update({
            isSuccessful: true,
            isSuccessfulReason: 'Batch processing completed'
        });
    });
}
```

## Multimodal Tracking

```typescript
import { LucidicAI } from 'lucidicai';
import OpenAI from 'openai';
import { readFile } from 'fs/promises';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function multimodalExample() {
    const openai = new OpenAI();

    await client.sessions.create({
        sessionName: 'Image analysis workflow'
    }, async () => {
        // Read and encode image
        const imageBuffer = await readFile('chart.png');
        const imageUrl = 'data:image/png;base64,' + imageBuffer.toString('base64');

        // Track the analysis event
        client.events.emit({
            name: 'Visual analysis started',
            input: { imageType: 'chart' }
        });

        // Use vision model - LLM call auto-tracked
        const response = await openai.chat.completions.create({
            model: 'gpt-4-vision-preview',
            messages: [{
                role: 'user',
                content: [
                    { type: 'text', text: 'Describe this chart' },
                    { type: 'image_url', image_url: { url: imageUrl } }
                ]
            }]
        });

        client.events.emit({
            name: 'Visual analysis complete',
            output: { description: response.choices[0].message.content }
        });
    });
}
```

## A/B Testing with Experiments

```typescript
import { LucidicAI } from 'lucidicai';
import OpenAI from 'openai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function runExperiment() {
    const openai = new OpenAI();

    // Define variations to test
    const prompts = [
        'Be concise',
        'Be detailed',
        'Be technical'
    ];

    const models = ['gpt-5.2', 'gpt-4'];

    // Experiment ID from dashboard
    const EXPERIMENT_ID = 'exp-123abc';

    for (const prompt of prompts) {
        for (const model of models) {
            await client.sessions.create({
                sessionName: `${model} - ${prompt}`,
                experimentId: EXPERIMENT_ID,
                tags: ['experiment', model, prompt]
            }, async () => {
                const response = await openai.chat.completions.create({
                    model,
                    messages: [
                        { role: 'system', content: prompt },
                        { role: 'user', content: 'Explain quantum computing' }
                    ]
                });

                // Evaluate and update session
                const score = evaluateResponse(response.choices[0].message.content);

                await client.sessions.update({
                    isSuccessful: score >= 80,
                    isSuccessfulReason: `Score: ${score}`
                });
            });
        }
    }
}
```

## Authentication Patterns

### Using Environment Variables

```typescript
// Set these in your environment:
// LUCIDIC_API_KEY=your-api-key
// LUCIDIC_AGENT_ID=your-agent-id

import { LucidicAI } from 'lucidicai';

const client = new LucidicAI({ providers: ['openai'] });

await client.sessions.create({
    sessionName: 'My Session'
}, async () => {
    // Your workflow
});
```

### Using dotenv

```typescript
import { LucidicAI } from 'lucidicai';
import dotenv from 'dotenv';

dotenv.config();

const client = new LucidicAI({ providers: ['anthropic'] });

await client.sessions.create({
    sessionName: 'My Session'
}, async () => {
    // Your workflow
});
```

### Direct Configuration

```typescript
import { LucidicAI } from 'lucidicai';

const client = new LucidicAI({
    apiKey: 'your-api-key',
    agentId: 'your-agent-id',
    providers: ['openai']
});

await client.sessions.create({
    sessionName: 'My Session'
}, async () => {
    // Your workflow
});
```

## Production Best Practices

```typescript
import { LucidicAI } from 'lucidicai';

// Custom masking function
const maskSSN = (text: string) => {
    return text.replace(/\b\d{3}-\d{2}-\d{4}\b/g, 'XXX-XX-XXXX');
};

const client = new LucidicAI({
    apiKey: '...',
    providers: ['openai', 'anthropic'],
    productionMonitoring: true  // Enable production mode
});

async function productionWorkflow() {
    await client.sessions.create({
        sessionName: 'Production agent',
        maskingFunction: maskSSN,
        tags: ['production', 'v1.2.3', 'us-west-2']
    }, async () => {
        try {
            await processUserRequest();

            await client.sessions.update({
                isSuccessful: true,
                isSuccessfulReason: 'Request processed successfully'
            });
        } catch (error) {
            // Error is auto-tracked
            await client.sessions.update({
                isSuccessful: false,
                isSuccessfulReason: `Error: ${error.message}`
            });
            throw error;
        }
    });
}
```

## Dataset Testing

```typescript
import { LucidicAI } from 'lucidicai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function runDatasetTests() {
    const datasetItems = await client.datasets.getItems('test_suite_v1');

    for (const item of datasetItems) {
        await client.sessions.create({
            sessionName: `Test: ${item.name}`,
            datasetItemId: item.id
        }, async () => {
            // Run agent with test input
            const result = await myAgent.process(item.input);

            // Validate against expected output
            const success = JSON.stringify(result) === JSON.stringify(item.expectedOutput);

            await client.sessions.update({
                isSuccessful: success,
                isSuccessfulReason: success
                    ? 'Output matched expected'
                    : 'Output did not match expected'
            });
        });
    }
}
```

## Prompt Management

```typescript
import { LucidicAI } from 'lucidicai';
import OpenAI from 'openai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function promptManagementExample() {
    const openai = new OpenAI();

    await client.sessions.create({
        sessionName: 'Prompt management demo'
    }, async () => {
        // Fetch prompt from Lucidic (cached by default)
        const systemPrompt = await client.prompts.get({
            promptName: 'customer-support-prompt',
            cacheTtl: 300  // Cache for 5 minutes
        });

        const response = await openai.chat.completions.create({
            model: 'gpt-4',
            messages: [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: userMessage }
            ]
        });

        // Response is auto-tracked
    });
}
```

## Parallel Processing

```typescript
import { LucidicAI } from 'lucidicai';

const client = new LucidicAI({ apiKey: '...', providers: ['openai'] });

async function parallelProcessing() {
    await client.sessions.create({
        sessionName: 'Parallel operations'
    }, async () => {
        // Run multiple operations in parallel
        const [analysis, summary, translation] = await Promise.all([
            analyzeText(content),
            summarizeText(content),
            translateText(content)
        ]);

        // Each LLM call is tracked as a separate event
        // All nested under the same session

        client.events.emit({
            name: 'Parallel processing complete',
            output: {
                analysisLength: analysis.length,
                summaryLength: summary.length,
                translationLength: translation.length
            }
        });
    });
}
```

## Next Steps

- Learn about [Core Concepts](/typescript-sdk/core-concepts)
- Explore [Provider Integrations](/typescript-sdk/integrations/openai)
- Read the [API Reference](/typescript-sdk/index)
- Understand [Advanced Features](/typescript-sdk/advanced-features)
